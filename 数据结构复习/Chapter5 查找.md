# Chapter5 查找

查找分为两种基本形式：

- 静态查找：在查找是只对数据元素进行查询或检索，查找表成为静态查找表。
- 动态查找：在查找的同时，插入查找表中不存在的记录，或从查找表中删除某个已存在的记录，查找表称作动态查找表。

## 衡量查找算法效率的标准

在查找过程中关键词的**平均比较次数**，这个标准也称为<font color=red>平均查找长度(ASL)</font>。

设查找的第i个元素的概率为$p_i$，查找到第i个元素所需要的比较次数为$c_i$，则查找成功的平均查找长度：

$ASL_{succ}=\sum_{i=1}^{n}p_i*c_i\ (\sum_{i=1}^np_i=1)$

## 顺序查找方法

数据以**线性表**的形式组织进行表示(成为查找表)，其存储结构既可以是连续设计也可以是链接设计。

查找过程：从表中**最后一个元素**开始，顺序用各个元素的关键字与定值x进行比较，一直查找到**第一个元素**，出现相等的元素则查找成功。

$ASL_{succ}=\frac{n+1}{2}$

$ASL_{Fail}=n+1$

## 折半查找

前提条件：查找表中的所有记录是按关键词**有序**组成的线性表。

在查找过程中，先确定查找记录在表中的范围，然后逐步缩小范围(每次缩小一半)，直到找到或找不到记录为止。

初值：设low,high,mid。

1. low=1,high=n,mid=(low+high)/2。
2. 比较mid位置的关键字与给定的k值。
   1. 相等：查找成功。
   2. 大于：记录应存放在区间前半段，high=mid-1，转回(1)。
   3. 小于：记录应存放在区间后半段，low=mid+1，转回(1)。
3. 直到越界(low>high)，查找失败。

由于每经过一次比较，查找范围就缩小一半，所以过程可以用一颗**二叉树**表示。这样得到的二叉树称为**判定树**。

ASL=$\sum_{i=1}^np_i*c_i=\frac{n+1}{n}log_2(n+1)-1$，当n>50时，ASL可近似将$\frac{n+1}{n}$当作1。

## 分块查找

又称索引顺序查找，是前两种查找方法的综合。

查找表的组织：

1. 将查找表分成几块，**块间有序**，即第i+1块的所有记录关键字均大于第i块记录关键字，**块内无序**。
2. 在查找表的基础上附加一个索引表，索引表是按关键词有序的。

<img src="C:\Users\hp\AppData\Local\Temp\WeChat Files\5e2bd8faac941431c2af6640753efed.jpg" alt="5e2bd8faac941431c2af6640753efed" style="zoom:33%;" />

算法分析：设表有n个记录，被分为b块，每块记录为s，**ASL=$\sum_{j=1}^bj+\frac{1}{s}\sum_{i=1}^si=\frac{b+1}{2}+\frac{s+1}{2}$**。

## Fibonacci查找

设查找表的记录数比某个Fibonacci数小1，即n=F(j)-1，用low，high和mid表示区间的上界、下界和分割位置，初值low=1,high=n。

1. 取分割位置**mid=F(j-1)+low-1**。
2. 比较分割位置记录的关键字与给定的k值。
   1. 相等：查找成功。
   2. 大于：待查记录在区间的前半段，high=mid-1。
   3. 小于：待查记录在区间的后半段，low=mid+1。
3. 直到越界。

Fibonacci查找最坏情况下性能不如折半查找，但是折半查找要求记录按关键字有序。

## 顺序索引表

按顺序结构组织的线性索引表，一般是按关键字排序。

优点：

- 可以用折半查找快速找到关键字。
- 提供对变长数据记录的便捷访问。
- 插入或删除数据是不需要移动记录，但是要对索引表进行维护。

缺点：

- 索引表中索引项数目与数据表中记录数相同，索引表很大时，检索需要多次访问外存。
- 维护代价较高，涉及大量索引项移动。

## 散列（哈希表）

### 哈希函数构造方法

#### 直接定址法

此类函数直接取关键字或关键字的某个**线性函数**值作为散列地址。

例如：Hash(key)=a*key+b(a，b为常数)。

一般为一对一映射，不会产生冲突，但是它要求**散列地址空间大小与关键字集合大小相同**。

#### 数字分析法

对n位数中选取符号均匀的几位数进行哈希映射，减少了冲突的可能。

#### 平方取中法

将关键字平方后取中间几位作为哈希地址。

**适用于事先不知道关键字分布情况且关键字的位数不是很大**的情况。

#### 折叠法

将关键字自左到右分为**位数相等**的几部分，每一部分的位数应与**散列表地址位数**相同，只有最后一部分位数可以短一些。

将几部分数据叠加起来，得到散列地址。

- 移位法：把各部分最后一位对齐相加。
- 分界法：各部分不折断，沿各部分分界来回折叠相加。

#### 除留余数法

hash(key)=key%p。

#### 随机数法

H(key)=random(key)。

### 散列技术

#### 线性探测法

当某个位置T[h]冲突时，依次探测T[h+1],T[h+2]...直到探测成功或失败。

优点：只要散列表未满，总存在不冲突的散列地址。

缺点：冲突的记录都被散列到离冲突最近的空地址上，从而**增加了更多冲突机会**。

#### 二次探测法

增量序列为：$d_i=1^2,2^2...k^2$。

若出现冲突，则以H(key)=H(key+$d_i$)进行二次探测。

优点：不容易产生冲突聚集的**聚集**现象。

缺点：不能保证探测到散列表的所有地址。

#### 伪随机探测法

如二次探测法，但是增量序列为随机数。

#### 再哈希法

准备多个不同的**哈希函数**，当发生冲突时，利用不同的哈希函数生成地址。

优点：不容易产生**聚集**。

缺点：计算时间增加。

#### 链地址法

将散列地址相同的关键字一起存储到一个**单链表**中，并用一维数组存放链表的头指针。

优点：不容易产生冲突**聚集**，删除记录也很简单。

#### 建立公共溢出区

另外设立一个溢出表，保存冲突的所有记录。

<img src="C:\Users\hp\AppData\Local\Temp\WeChat Files\8c6330d385a6bd50d40f5211057564d.jpg" alt="8c6330d385a6bd50d40f5211057564d" style="zoom:33%;" />

### 哈希查找分析

查找时的比较次数取决于：

- 哈希函数
- 处理冲突的方法
- 哈希表的填满因子$\alpha$，其定义为：$\alpha=\frac{表中填入的记录数}{哈希表长度}$。

<img src="C:\Users\hp\AppData\Local\Temp\WeChat Files\92480edae080f952dd251d01d8dedc4.jpg" alt="92480edae080f952dd251d01d8dedc4" style="zoom:50%;" />