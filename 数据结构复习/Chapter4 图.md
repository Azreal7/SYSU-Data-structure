# Chapter4 图

完全图：**每个结点之间都是联通**的图称作完全图。

- 在具有n个顶点的有向图中，最大弧数为n(n-1)。
- 在具有n个顶点的无向图中，最大弧数为n(n-1)/2。

连通图与连通分量：

- 顶点的连通性：在**无向图**中，若从顶点$v_i$到顶点$v_j$(i$\not=$j)有路径，则称顶点$v_i和v_j$是连通的。
- 连通图：如果无向图中任意一对顶点都是连通的，则称此图为连通图。
- 连通分量：连通图的<font color=red>极大连通子图</font>叫做连通分量。

强连通图与强连通分量：

- 顶点的强连通性：在**有向图**中，若从顶点$v_i$到顶点$v_j$和从顶点$v_j$到顶点$v_i$(i$\not=$j)有路径，则称顶点$v_i和v_j$是强连通的。
- 强连通图：如果有向图中任意一对顶点都是强连通的，则称此图为强连通图。
- 强连通分量：连通图的<font color=red>极大强连通子图</font>叫做强连通分量。

生成树：假设连通图有n个顶点和e条边，其中n-1条边和n个顶点构成一个极小连通子图，则称该**极小**连通子图为此连通图的<font color=red>生成树</font>。

## 图的存储表示

### 邻接矩阵表示法

- 顶点表：一个**记录各个顶点信息**的一维数组。
- 邻接矩阵：一个**表示各个顶点之间的关系**的二维数组。

![2c635d9e7a63882c313d93c7e082ba8](C:\Users\hp\AppData\Local\Temp\WeChat Files\2c635d9e7a63882c313d93c7e082ba8.jpg)

### 邻接表

- 邻接表：图的一种链式存储结构。

- 边的结点结构：

  |                    |                    |                |
  | ------------------ | ------------------ | -------------- |
  | 该弧指向的结点位置 | 指向下一条边的指针 | 该边的相关信息 |

- 顶点的结点结构：

|          |                        |
| -------- | ---------------------- |
| 顶点信息 | 指向第一条依附该边的弧 |

![b7e8d75d2f2701d3bf177d4e6becc24](C:\Users\hp\AppData\Local\Temp\WeChat Files\b7e8d75d2f2701d3bf177d4e6becc24.jpg)

而邻接表也根据存储的为**出度**还是**入度**信息分为了**正邻接表**和**逆邻接表**。

### 有向图的十字链表

- 可以看作是将有向图的正邻接表和逆邻接表结合起来得到的链式存储结构。
- 即弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上。
- 从横向上看是**正邻接表**，从纵向上看是**逆邻接表**。

<img src="C:\Users\hp\AppData\Local\Temp\WeChat Files\5fa4b010a3529da457e6fcc6a18fbf7.jpg" alt="5fa4b010a3529da457e6fcc6a18fbf7" style="zoom: 33%;" />

<img src="C:\Users\hp\AppData\Local\Temp\WeChat Files\79070ac9448022d76334ff9e14b6e17.jpg" alt="79070ac9448022d76334ff9e14b6e17" style="zoom: 50%;" />

### 无向图的邻接多重表

- 邻接多重表是无向图邻接矩阵的一种**压缩表示**。
- 在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，这样每条边在存储结构中**直接依附两个顶点**，每个边结点同时链接在两个链表中。

<img src="C:\Users\hp\AppData\Local\Temp\WeChat Files\67917724da76416509e69b7d54f3864.jpg" alt="67917724da76416509e69b7d54f3864" style="zoom:33%;" />

## 图的遍历

DFS,BFS跳过

DFS若用邻接表表示，时间复杂度为<font color=red>O(n+e)</font>。若用邻接矩阵表示，时间复杂度为<font color=red>$O(n^2)$</font>。

BFS若用邻接表表示，时间复杂度为<font color=red>O(e)</font>。若用邻接矩阵表示，时间复杂度为<font color=red>$O(n^2)$</font>。

## 图的连通性问题

关节点：在一个无向连通图G中，当且仅当删除G中的顶点v及其所关联的边后，可将图分割成2个或2个以上的连通分量，则称顶点v为**关节点**，或者称为**割项**。

重连通图：不存在关节点的连通图。

重连通分量：如果连通图G不是重连通图，那么它可以包括几个重连通分量。一个连通图的重连通分量是该图的**极大连通子图**。

### 求关节点的算法

先取任意点通过**深度优先搜索**建立生成树，随后：

- 若树中存在结点拥有**两个子树**，则该结点为关节点。
- 若树中存在某个非叶子节点V，若V存在某棵子树，其中所有结点都不存在指向V祖先的**回边**(在生成树中u为v的祖先或v为u的祖先，非生成树的边(u,v)才被成为回边)，则结点V为关节点。

### 有向图的强连通分量

求有向图G的强连通分量的基本步骤是：

1. 对G进行深度优先遍历，生成G的深度优先生成森林T。
2. 对森林T的顶点按照中序遍历顺序进行编号。
3. 改变G中每一条弧的方向，构成一个新的有向图G'。
4. 按(2)中标出的定点编号，从编号最大的顶点来对G'进行深度优先搜索。得到一棵深度优先生成树，树中顶点为一个强连通分量中的所有顶点。
5. 对剩下未访问的顶点重复(4)操作，直到所有顶点访问完。

## 最小生成树

### Prim算法

从某一顶点$u_0$出发，选择与它关联的具有**最小权值**的边($u_0$,v)，将其顶点加入生成树的集合U中。

之后每一步都从一个顶点在U中，另一个顶点不在U中的边中选择权值最小的边，将边加入边集之中，顶点也加入生成树集合。

### Kruskal算法

从整个图E中选取**最小权值**边，先设每个点都为一个连通分量。

循环直到E中连通分量为1，选取边然后将两个连通分量合二为一。

## 拓扑排序

跳过

## AOE网络

求事件$v_i$的最早可能开始时间ve[i]和最迟允许开始时间vl[i]。

ve从正向递推，vl从反向递推。

$ve[i] = max\{ve[j] +dur(<v_j,v_i>)\}$

$vl[i] = min\{vl[j]-dur(<v_j,v_i>)\}$

随后求出活动(即边)的最早开始时间e[k]和最迟允许开始时间l[k]。

e[k]=ve[i]，l[k]=vl[j]-dur(<i,j>)。

随后计算时间余量l[k]-e[k]，**时间余量为0的活动**为关键活动。

## 最短路径问题

### Dijkstra算法

类似Prim。

### Floyd算法

而求所有顶点之间的最短路径，则是先列出所有已知边长，随后以$D[i,j]=min((D[i,k],D[k,j]),D[i,j])$进行遍历，即可得到所有顶点的最短路径。时间复杂度为O($n^3$)。