# Chapter3 树

树形结构是以<font color=red>分支关系定义的层次结构</font>。

## 树的定义

树是一个由n个结点的有限集合T，若n=0时称为空树。否则：

- 有且只有一个特殊的成为树的**根**的结点。
- 没有空的子树。

结点的度：结点的子树个数。

兄弟节点：具有同一双亲的所有节点。

## 树的存储设计

### 双亲表示法

双亲表示法主要描述的是**结点与双亲**的关系。

形式为：info(结点)->parent(父母结点)

### 孩子表示法

孩子表示法主要是描述**结点与孩子**之间的关系，由于每个结点的孩子个数不定，所以利用**链式存储**更加适合。

形式为：$info->child_1->...->child_n$。

### 孩子兄弟表示法

孩子兄弟表示法也是一种**链式存储结构**，描述每个节点一个孩子和兄弟信息来反映结点之间的**层次关系**。

![双亲表示法、孩子表示法、孩子兄弟表示法(二叉树表示法)，森林和二叉树的转换_Charming Boy的博客-CSDN博客_孩子兄弟表示法](https://img-blog.csdnimg.cn/20200122121504359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg5NTAyNg==,size_16,color_FFFFFF,t_70)

## 二叉树

结构特点：

- 结点的度不大于**2**。
- 子树有左右之别，子树的次序**不能颠倒**。
- 即使某结点只有一个子树，也有**左右之分**。

### 满二叉树

定义：高度为K且有$2^K-1$个结点的二叉树称为<font color=red>满二叉树</font>。

结构特点：

- 分支节点都有两棵子树。
- 叶子结点都在最后一层。

### 完全二叉树

定义：满足下列性质的二叉树(假设高度为k)称为完全二叉树。

- 所有叶子节点都出现在第k层和第k-1层。
- 第k层的叶子都出现在该层的最左边。

### 性质

1. 若二叉树的层次从1开始，则二叉树的第i层最多有$2^{i-1}$个结点。
2. 高度为k的二叉树最多有$2^k-1$个结点。
3. 对任何一棵二叉树，如果其叶结点个数为$n_0$，度为2的非叶结点个数为$n_2$，则有$n_0=n_2+1$。
   1. 结点总数为度为0的结点加上度为1的结点加上度为2的结点：$n=n_0+n_1+n_2$
   2. 二叉树中一度结点有1个孩子，二度结点有2个孩子，因此：$n=n_1+2n_2+1$
   3. 两式相减得到结论式子。
4. 具有n个结点的完全二叉树的高度为$[log_2n]+1$。
5. 如果将一棵有n个结点的<font color=red>完全二叉树</font>自上而下，同一层自左向右连续给结点编号1，2，...，n，然后按此编号将树中各个结点顺序地放入一个一维数组中，并简称编号为i的结点为结点i。则具有以下关系：
   1. 若i=1，则i无双亲，若i>1，则双亲为[i/2]。
   2. 若$2*i\leq n$则i的左子女为2*i，否则，i无左子女，必定是叶节点，**二叉树中i>[n/2]的结点必定是叶结点**。2\*i+1$\leq$右结点同理。
   3. 若i为奇数，且i不为1，则其左兄弟为i-1，否则无左兄弟；若i为偶数，且小于n，则其右兄弟为i+1，否则无右兄弟。
6. i所在的层次为$[log_2i]+1$。

### 存储设计

1. 连续设计存储
   - 类似于树的顺序存储表示：双亲表示法。
   - 直接用数组进行存储(仅适用于完全二叉树)。
2. 链式存储设计

### 二叉树的遍历

前、中、后省略

非递归算法：利用栈，将已访问但是之后仍需要访问的结点存储到栈中，进行遍历。

层次遍历二叉树：利用queue。

伪代码：

```c++
void LevelorderTraverse(BTNode *T) {
	BTNode *Queue[100], *p = T;
    int front = 0, rear = 0;
    if(p != nullptr) {
        Queue[++rear] = p; /*根节点入队*/
        while(front < rear) {
            p = Queue[++front]; visit(p->data);
            if(p->Lchild != nullptr) Queue[++rear] = p;
            if(p->Rchild != nullptr) Queue[++rear] = p;
        }
    }
}
```

## 线索树

设一棵二叉树右n个结点，则有n-1条边，而n个结点共有2n个指针域，显然有n+1个空闲指针域未用，因此做出以下规定：

- 若节点有左孩子，则Lchild指向其左孩子，否则指向其直接前驱。
- 若结点有右孩子，则Rchild指向其右孩子，否子指向其直接后继。

为避免混淆，对结点结构进行改进，增加Ltag和Rtag两个标志域，来表示结点存储的是前后继还是孩子。

### 线索化二叉树

1. 左子树线索化。
2. 对空指针线索化：
   1. 如果p的左孩子为空，给p加上左线索，Ltag置为1。
   2. 如果pre的右孩子为空，给pre加上右线索，Rtag置为1。
3. pre=p。
4. 右子树线索化。

## 森林与二叉树的转换

### 树转化为二叉树

每个结点的左子节点仍为原本的左子节点，右子节点变为兄弟节点。

<img src="C:\Users\hp\AppData\Local\Temp\WeChat Files\956a72d644a151a1105277aef424951.jpg" alt="956a72d644a151a1105277aef424951" style="zoom: 33%;" />

### 森林转化为二叉树

先将森林中各个树转化为二叉树，随后将各个根节点从左到右依次以**右子节点**连接起来。

![7f36c251e7ae8b9c0f2d76381bfb299](C:\Users\hp\AppData\Local\Temp\WeChat Files\7f36c251e7ae8b9c0f2d76381bfb299.jpg)

### 二叉树转森林

根节点的右子节点分离开来，随后二叉树转普通树。

## 哈夫曼树

带权路径长度(WPL)最短的二叉树。**权值大的结点离根最近**。

构造方法见[matrix]([Matrix - The art of coding (sysu.edu.cn)](https://matrix.sysu.edu.cn/course/private/900276/assignment/1514169))。

### 哈夫曼编码

最优前缀码：平均编码长度$\sum p_j*l_j$最小的前缀编码称为**最优前缀码**。

特点：

- 哈夫曼编码具有**前缀性**。
- 哈夫曼编码是**最小冗余码**（每个码只出现一次）。
- 哈夫曼编码方法，使出现概率大的字符对应的码长较短。
- 哈夫曼编码**不唯一**，可以用于加密。
- 哈夫曼编码译码简单**唯一**，没有二义性。

## 其他

二叉查找树，AVL树，B树，B+树，见之前的md文件。

B树与B+树的重要区别为：**B+树的元素只存放在叶结点中**，便于范围查询。